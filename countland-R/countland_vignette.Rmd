# COUNTLAND: R tutorial
### Samuel H. Church

This tutorial demonstrates the major functions of `countland` by applying them to a Gold standard single-cell RNA sequencing dataset from [Freytag _et al_ (2018)](10.12688/f1000research.15809.2).

`countland` is a **barebones** set of functions for applying a restricted linear algebra to the analysis of count-based data. As such, there are many opportunities for further optimization that may prove useful in the anlaysis of your own data. We provide the source code freely available at https://github.com/shchurch/countland and encourage users and developers to fork the code for their own purposes.

The following packages are required to complete the tutorial

```{r load}
library(Seurat)
library(ggplot2)
theme_set(theme_classic())
```

## GET THE DATA

We have used the Gold standard dataset provided by [Freytag _et al_ (2018)](10.12688/f1000research.15809.2). This data consists of ~1000 cells that have ground truth labels corresponding to three human lung cell lines.

`countland` accepts an sparse data matrix (as does `Seurat`). 

```{r data}
gold.data <- Seurat::Read10X(data.dir = "../data/Gold_Freytag2018/")
m <- gold.data
```

## IMPORT COUNTLAND
The source code for `countland` in `R` is located in `countland-R/R/`

```{r source}
source("R/countland.R")
source("R/countland_cluster.R")
source("R/countland_rank_reduction.R")
source("R/countland_genes.R")
source("R/countland_utils.R")
```

## INITIALIZE COUNTLAND OBJECT

Initialize `countland` by calling the core function on sparse data matrix.

```{r init}
C <- countland(m)
```
The count matrix is stored in `C@counts`

```{r count-matrix}
C@counts[1:10,1:10]
```

Note that most counts are zero for scRNA-seq data.

## EVALUATE DATA QUALITY

We can establish data quality by checking the total number of counts and other expression measures per cell.

In addition, it can be helpful to see how many counts are derived from certain genes, such as mitochondrial genes (here we have chosen a gene name with particularly high counts, regular expressions are permitted for name matching).

Expression measures include:
- maximum number of counts observed across genes
- total counts
- number of genes with observed counts
- number of genes with counts above 1, or 10
- number of unique count values per cell
- count index = number of _n_ genes with _n_ counts

```{r cell-score}
# flag genes starting with MT (mitchondrial genes)
gene_string <- "^ENSG00000140988$"
C <- ScoreCells(C,gene_string)
head(C@cell_scores)
```

## FILTER DATA

Standard workflows often filter data based on quality measures, such as the number of unique features per cell. 

```{r filt-cell}
filter_cell_names <- C@cell_scores[C@cell_scores$n_features < 8500,]$names
filter_cell_index <- which(C@names_cells %in% filter_cell_names) # cells with fewer than 8,500 unique features
C <- SubsetCells(C,filter_cell_index,remove_empty=FALSE)
```

```{r filt-gene}
# row positions (i) represent observations of a gene
obsgenes <- unique(C@counts@i)
# sort and index starting at 1 rather than 0
obsgenes <- sort(obsgenes+1)
C <- SubsetGenes(C,obsgenes) # genes with observations

# note the same could be accomplished by running
#     C <- SubsetCells(C,filter_cells,remove_empty=TRUE)
# above
```

With `countland`, such data filtering may not be necessary or helpful. The original count matrix can be restored at any time.

```{r restore}
C <- RestoreCounts(C)
```

## SUBSAMPLE GENES

Cells are not sequenced to standard sequencing depth. This is sometimes a problem for downstream comparisons.  

You can create an alternative count matrix where cells have an equal number of counts using `Subsample()`. The number of counts must not be larger than the minimum number per cell.

This matrix is stored in `C@subsample`

```{r subsample}
set.seed(84095)
C <- Subsample(C,n_counts=1000)
```

## COMPARE GENES BY COUNTS

Using the subsampled count matrix, we can make comparisons of gene expression using several count-based assessments. These include:

- maximum number of counts observed across cells
- total counts
- number of cells with observed counts
- number of cells with counts above 1, or 10
- number of unique count values
- count index = number of _n_ cells with _n_ counts

```{r gene_scores}
C <- ScoreGenes(C)
head(C@gene_scores)
```
We can also visualize counts across genes with a stripplot

```{r plot-genes}
top_genes <- which(C@names_genes %in% head(C@gene_scores[order(-C@gene_scores$unique_count_values),],9)$names)
PlotGeneCounts(C,top_genes)
```

## COMPARE CELLS AND CLUSTER

The dot (or inner) product is a measure of alignment between vectors. In this case, it tells us how similar two cells are based on the proportions of counts, and scaled by the total counts per cell. A dot product of 0 indicates orthogonal cell vectors (no shared counts), larger values indicate aligned cell vectors.

```{r dots}
C <- Dot(C)
```
    
Cell populations can be compared and distinguished by embedding and clustering the matrix of pairwise dot products (contained in `C.dots`). This matrix is an unbounded affinity matrix. It is symmetric, and contains only integer values above 0. Spectral embedding clustering is appropriate for this type of matrix.

First, we embed to investigate the optimal number of clusters for our data.

```{r embed}
C <- Embed(C)
```

The eigengap heuristic is can help decide the optimal number of clusters, but it is only a guideline. According to this heuristic, the optimal number of clusters is _k_ where the difference in eigenvalues $ | e_{k+1} - e_{k} | $ is largest.

```{r eigengap}
PlotEigengap(C)
```
For many datasets, you may want to consider other factors, e.g. choosing a minimum number of clusters, whether or not the eigengap reflects this.

Here we have chosen 3 as the optimal number of clusters.

```{r cluster}
C <- Cluster(C,n_clusters=3)
```

### VISUALIZING WITH SPECTRAL EMBEDDING OF DOT PRODUCTS

We can now visualize clusters using spectral embedding.

```{r plot-cluster}
PlotEmbedding(C)
```

## IDENTIFY MARKER GENES

What makes a gene an ideal marker for a cluster may depend on downstream applications. For example, the ideal marker gene might be defined as the gene detected in all of the  cells in a given cluster and none of the rest.

Under this definition, the top marker gene for each cluster can be identified by counting and comparing the number of non-zero cells.

```{r marker-zero}
C <- RankMarkerGenes(C,method='prop-zero')
C@marker_genes[(C@marker_genes$cluster_label == 1),]
```
```{r plot-marker-zero}
cluster_marker <- C@marker_genes[C@marker_genes$cluster_label == 1,]
cluster_top <- cluster_marker[cluster_marker$rank == 1,]$names
gene_index = which(C@names_genes == cluster_top)
PlotMarker(C,gene_index)
```

Alternatively, the top marker genes for each cluster can be identified by ranking genes using the Wilcoxon rank-sum statistic.

```{r marker-ranks}
C <- RankMarkerGenes(C,method='rank-sums')
C@marker_genes[(C@marker_genes$cluster_label == 1),]
```
```{r plot-marker-ranks}
cluster_marker <- C@marker_genes[C@marker_genes$cluster_label == 1,]
cluster_top <- cluster_marker[cluster_marker$rank == 1,]$names
gene_index = which(C@names_genes == cluster_top)
PlotMarker(C,gene_index)
```
## OTHER VISUALIZATIONS

### UMAP OF RAW COUNTS
Alternative to spectral embedding and clustering, we can borrow a page from standard workflows and implement a uniform manifold approximation and projection (UMAP) for dimensional reduction in `countland`. Here this is applied to raw, rather than transformed counts. These can be either subsampled to standard number of counts across cells or the standard count matrix.

```{r umap}
PlotUMAP(C,subsample=TRUE)
```

### GLM-PCA

An alternative approach for comparing cells using untransformed counts is generalized linear model based PCA, or GLM-PCA. This has been described for scRNA-seq data [here](https://doi.org/10.1186/s13059-019-1861-6) and implemented [here](https://github.com/willtownes/glmpca-py).

**Note this can take some time.**

```{r glmpca}
#install.packages("glmpca")
library(glmpca)
res <- glmpca(as(C@counts,"matrix"),2)
```

```{r plot-glmpca}
factors <- res$factors
glmpca_df <- data.frame("component_1" = factors[,1],"component_2"=factors[,2],"cluster"=C@cluster_labels)
	ggplot(glmpca_df,aes(x = component_1,y = component_2, color=as.character(cluster))) +
  geom_point(size=1) +
  guides(color=guide_legend(title="cluster")) +
  scale_color_manual(values=color_palette)
```


